# 자바가 확장한 객체 지향
자바가 객체 지향을 확장하기 위해 사용하는 키워드와 개념
<hr/>

### abstract 키워드 - 추상 메서드와 추상 클래스
추상 메서드 - 선언부는 있는데 구현부가 없는 메서드 <br/>
추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 한다.
> 추상클래스는 인스턴스, 즉 객체를 만들 수 없는 클래스다.<br/>
> 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제.
<hr/>


### 생성자
반환값이 없고 클래스명과 같은 이름을 가진 메서드를 객체를 생성하는 메서드라고 해서 객체 생성자 메서드라 한다.<br/>
그리고 줄여서 생성자라는 이름으로 부른다.
* 개발자가 아무런 생성자도 만들지 않으면 자바는 컴파일 과정에서 컴파일러가 인자가 없는 기본 생성자를 자동으로 만들어준다.
* 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.
> 생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다. 그리고 생성자로 줄여서 부르지만 정확하게 표현하자면 객체 생성자 메서드이다.
<hr/>

### 클래스 생성 시의 실행 블록, static 블록
클래스 생성자는 존재하지 않는다. 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드블록이 있다. 바로 static블록이다.
```
public class 동물{
  static{
    System.out.println("동물 클래스 레디 온!");
  }
}
```
static 블록에서 사용할 수 있는 속성과 메서드는 당연히 static 멤버 뿐이다.
> 앞에서는 프로그램이 시작될 때 모든 패키지와 모든 클래스가 T 메모리의 스태틱 영역에 로딩된다고 설명했지만,<br/>
> 실제로는 해당 패키지 또는 클래스가 처음으로 사용 될 때 로딩되는 것이 맞다.

* 동물 클래스의 인스턴스를 여러 개 만들어도 동물 클래스의 static 블록은 단 한 번만 실행된다.

클래스가 제일 처음 사용될 때
1. 클래스의 정적 속성을 사용할 때
2. 클래스의 정적 메서드를 사용할 때
3. 클래스의 인스턴스를 최초로 만들 때
> 메모리는 최대한 늦게 사용을 시작하고 최대한 빨리 반환하는 것이 정석이다.	<br/>
> 자바는 스태틱 영역에 한번 올라가면 프로그램이 종료되기 전까지는 해당 메모리를 반환할 수 없지만 그럼에도 최대한 늦게 로딩함으로써 메모리 사용을 최대한 늦추기 위해서다.<br/>
* 인스턴스를 위한 인스턴스 블록도 존재한다. 아무런 표시없이 {}블록을 사용하게 되면 인스턴스가 생성될 때마다 {}블록이 실행된다. {}블록은 객체 생성자가 샐행되기 전에 먼저 실행된다.
<hr/>

### final 키워드
final은 마지막, 최종이라는 의미를 가진 단어. final 키워드가 나타날 수 있는 곳은 딱 세군데다.<br/>
사실 객체 지향 언어의 구성 요소는 딱 세 가지 뿐이다. **클래스**, **변수**, **메서드**

#### final과 클래스
상속을 허락하지 않겠다는 의미다.(하위 클래스를 만들 수 없다.)

#### final과 변수
변경 불가능한 상수가 된다.
* 정적 상수는 선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화가 가능하다.
* 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화할 수 있다.
* 지역 상수 역시 선언 시에, 또는 최초 한 번만 초기화가 가능하다.

#### final과 메서드
메서드가 final이라면 최종이니 재정의, 즉 오버라이딩을 금지하게 된다.
<hr/>

### instanceof 연산자
instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자다.<br/>
instanceof 연산자는 결과로 ture 또는 false를 반납한다.
```
객체참조변수 instanceof 클래스명
```
> 객체 참조 변수의 타입이 아닌 실제 객체의 타입에 의해 처리한다.
> instanceof 연산자는 클래스들의 상속 관계뿐만 아니라 인터페이스의 구현 관계에서도 동일하게 적용된다.
<hr/>

### package 키워드
package 키워드는 네임스페이스(이름공간)를 만들어주는 역할을 한다.<br/>
같은 이름의 클래스라도 패키지가 다르면 이름 충돌을 피할 수 있다.
<hr/>

### interface 키워드와 implements 키워드
인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다.
* 인터페이스는 추상 메서드와 정적 상수만 가질 수 있기에 따로 메서드에 public과 abstract, 속성에 public과 static, final을
붙이지 않아도 자동으로 자바가 알아서 붙여준다.
* 다음 두 코드는 동일하다.
```
interface Seakable {
  doublic PI = 3.14159;
  final double absoluteZeroPoint = -275.15;
  
  void sayYes();
}
```
```
interface Seakable {
  public static final doublic PI = 3.14159;
  public static final double absoluteZeroPoint = -275.15;
  
  public abstract void sayYes();
}
```
> 아래의 코드를 권장한다. 인터페이스의 기본 규칙을 모르는 사람이라도 명확하기 때문이다.
<hr/>

### this 키워드
this는 객체가 자기 자신을 지칭할 때 쓰는 키워드다. 
* 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
* 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다.
* 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용한다.
<hr/>

### super 키워드
단일 상속만을 지원하는 자바에서 super는 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드다.
> super 키워드로 바로 위의 상위 클래스 인스턴스에는 접근할 수 있지만 super.super 형태로 상위의 상위 클래스의 인스턴스에는 접근이 불가능하다.
<hr/>

### 참고
객체 멤버 메서드는 각 객체별로 달라지는 것이 아니다. 객체 멤버 메서드에서 사용하는 객체 멤버 속성의 값만 다를 뿐이다. 
똑같은 객체 멤버 메서드를 힙 영역에 여러개 만든다는 것은 심각한 메모리 낭비라고 할 수 있다.
그래서 JVM은 지능적으로 객체 멤버 메서드를 스태틱 영역에 단 하나만 보유한다.
그리고 눈에 보이지는 않지만 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.
> 객체 멤버 메서드는 JVM에 의해 정적 멤버 메서드로 변경된다.
<hr/>

### 자바 키워드와 OOP 확장
* 절차적/ 구조적 프로그래밍의 유산
  * continue, for, switch, default, goto, package, boolean, do, if, break, double, byte, else, import, case, return, int, short, char, void, long, strictfp, volatile, const, float, native, while
* 객체 지향 4대 특성 지원
  * new, private, protected, public, extends, static, class
* 객체 지향 확장 지원
  * abstract, this, implements, enum, instanceof, final, interface, super
* 기타(예외 처리 지원, 멀티 스레드 지원, 직렬화 지원 키워드)
  * assert, synchronized, throw, throws, transient, try, catch, finally
