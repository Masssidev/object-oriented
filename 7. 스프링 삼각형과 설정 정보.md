# 스프링 삼각형과 설정 정보
스프링을 이해하는 데는 POJO(Plain Old Java Object)를 기반으로 스프링 삼각형이라는 애칭을 가진<br/>
IoC/DI, AOP, PSA라고 하는 스프링의 3대 프로그래밍 모델에 대한 이해가 필수다.
<hr/>

### IoC/DI - 제어의 역전/의존성 주입
의사 코드
```
운전자가 자동차를 생산한다.
자동차는 내부적으로 타이어를 생산한다.
```
자바로 표현
```
new Car();
Car 객체 생성자에서 new Tire();
```
> 의존성은 new다.<br/> new를 실행하는 Car와 Tire 사이에서 Car가 Tire에 의존한다.<br/>
> 결론적으로 전체가 부분에 의존한다고 표현할 수 있다.

#### 스프링 없이 의존성 주입하기 1 - 생성자를 통한 의존성 주입
의사코드
```
운전자가 타이어를 생산한다.
운전자가 자동차를 생산하면서 타이어를 장착한다.
```
자바로 표현
```
Tire tire = new KoreaTire();
Car car = new Car(tire);
```
주입이란 말은 외부에서라는 뜻을 내포하고 있는 단어이다.<br/>
자동차 내부에서 타이어를 생산하는 것이 아니라 외부에서 생산된 타이어를 자동차에 장착하는 작업이 주입이다.
* 자동차가 생산될 때 어떤 타이어를 생산해서 장착할까를 자동차가 스스로 고민하지 않고, 운전자가 차량을 생산할 때 운전자가 어떤 타이어를 장착할까를 고민하게 하는 것이다.<br/>
* 의존성 주입을 적용할 경우 Car는 그저 Tire 인터페이스를 구현한 어떤 객체가 들어오기만 하면 정상적으로 작동하게 된다.<br/>
* 의존성 주입을 하면 확장성도 좋아지는데, 나중에 ChinaTire, JapanTire, EnglandTire 등등 어떤 새로운 타이어 브랜드가 생겨도 각 타이어 브랜드들이 Tire
인터페이스를 구현한다면 Car.java 코드를 변경할 필요 없이 사용할 수 있기 때문이다.(또한 다시 컴파일할 필요도 없다.)
> 현실 세계의 표준 규격 준수 = 프로그래밍 세계의 인터페이스 구현

#### 스프링 없이 의존성 주입하기2 - 속성을 통한 의존성 주입
의사코드
```
운전자가 타이어를 생산한다.
운전자가 자동차를 생산한다.
운전자가 자동차에 타이어를 장착한다.
```
자바로 표현 - 속성 접근자 메서드 사용
```
Tire tire = new KoreaTire();
Car car = new Car();
car.setTire(tire);
```
> 생성자를 통해 의존성을 주입하는 것은 한번 생산하면 더 이상 타이어를 교체하지 못한다.<br/>
> 따라서 생성자가 아닌 속성을 통한 의존성 주입이 필요하다.

#### 스프링을 통한 의존성 주입 - XML 파일 사용
의사 코드
```
운전자가 종합 쇼핑몰에서 타이어를 구매한다.
운전자가 종합 쇼핑몰에서 자동차를 구매한다.
운전자가 자동차에 타이어를 장착한다.
```
자바로 표현(속성을 통한 주입)
```
ApplicationContext context = new ClassPathXmlApplicationContext("expert002.xml", Driver.class);
Tire tire = (Tire)context.getBean("tire");
Car car = (Car)context.getBean("car");
car.setTire(tire);
```
스프링을 도입해서 얻는 이득
* 자동차의 타이어 브랜드를 변경할 때 그 무엇도 재컴파일/재배포하지 않아도 XML 파일만 수정하면 프로그램의 실행 결과를 바꿀 수 있다.

#### 스프링을 통한 의존성 주입 - 스프링 설정 파일(XML)에서 속성 주입
의사 코드 - 점점 더 현실 세계를 닮아가고 있다.
```
운전자가 종합 쇼핑몰에서 자동차를 구매 요청한다.
종합 쇼핑몰은 자동차를 생산한다.
종합 쇼핑몰은 타이어를 생산한다.
종합 쇼핑몰은 자동차에 타이어를 장착한다.
종합 쇼핑몰은 운전자에게 자동차를 전달한다.
```
자바로 표현
```
ApplicationContext context = new ClassPathXmlApplicationContext("expert003/expert003.xml");
Car car = context.getBean("car", Car.class);
```
XML 로 표현
```
<bean id = "koreaTire" class = "expert003.KoreaTire"></bean>
<bean id = "americaTire" class = "expert003.AmericaTire"></bean>
<bean id = "car" class = "expert003.Car">
  <property name = "tire" ref = "koreaTire"></property>
</bean>
```
> XML 파일에 새롭게 property라고 하는 부분은 자바에서 접근자 및 설정자 메서드를 속성 메서드라고 하는데 영어로 속성은 Property다.
결국 car.setTire(tire)라고 하던 부분을 XML 파일의 property 태그를 이용해 대체하는 것이다.

#### 스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입
의사 코드
```
운전자가 종합 쇼핑몰에서 자동차를 구매 요청한다.
종합 쇼핑몰은 자동차를 생산한다.
종합 쇼핑몰은 타이어를 생산한다.
종합 쇼핑몰은 자동차에 타이어를 장착한다.
종합 쇼핑몰은 운전자에게 자동차를 전달한다.
```
창조적 게으름<br/>
##### @Autowired
스프링 프레임워크가 설정 파일을 통해 설정자 메서드 대신 속성을 주입해준다.

> 스프링의 @Autowired는 type 기준 매칭이다. 만약 같은 타입을 구현한 클래스가 여러 개 있다면 그때 bean 태그의 id로 구분해서 매칭하게 된다.

#### 스프링을 통한 의존성 주입 - @Resource를 통한 속성 주입
의사 코드
```
운전자가 종합 쇼핑몰에서 자동차를 구매 요청한다.
종합 쇼핑몰은 자동차를 생산한다.
종합 쇼핑몰은 타이어를 생산한다.
종합 쇼핑몰은 자동차에 타이어를 장착한다.
종합 쇼핑몰은 운전자에게 자동차를 전달한다.
```
> @Resource는 자바 표준 어노테이션이다.<br/>(@Autowired는 스프링의 어노테이션-스프링 프레임워크를 사용하지 않는다면 사용할 수 없다.)<br/>
> @Resource의 경우 type과 id 가운데 매칭 우선순위는 id가 높다.<br/>
> (id로 매칭할 빈을 찾지 못한 경우 type으로 매칭할 빈을 찾게 된다.)

##### @Autowired와 @Resource 중에서는 @Resource 추천
* 나중에 스프링이 아닌 다른 프레임워크로 교체되는 경우를 대비하면 자바 표준인 @Resource를 쓰는 것이 유리함.
##### @Resource와 property 중에서는 property 추천
* DI 관계를 손쉽게 확인할 수 있기 때문.
* 유지보수성이 좋음.
* 재컴파일/재배포 필요 없음.
  
> 의존 관계가 new라고 단순화했던 부분뿐만 아니라 사실 변수에 값을 할당하는 모든 곳에 의존 관계가 생긴다.<br/>
> 즉, 대입연산자(=)에 의해 변수에 값이 할당되는 순간 의존이 생긴다.<br/>
> 의존 대상이 내부에 있을 수도 있고, 외부에 있을 수도 있다.<br/>
> DI는 외부에 있는 의존 대상을 주입하는 것을 말한다.<br/>
> 의존 대상을 배치할 때 SOLID와 응집도는 높이고 결합도는 낮춘다.<br/>
> 그래야 프로젝트의 구현과 유지보수가 수월해진다.
<hr/>

### AOP - Aspect? 관점? 핵심 관심사? 횡단 관심사?
Aspect-Oriented Programming: 관점 지향 프로그래밍

DI가 의존성에 대한 주입이라면 AOP는 로직주입이다.<br/>
다수의 모듈에 공통적으로 나타나는 부분이 존재하는데, 바로 이것을 횡단 관심사라고 한다.<br/>
**코드 = 핵심 관심사 + 횡단 관심사**<br/>
핵심 관심사는 모듈별로 다르지만 횡단 관심사는 모듈별로 반복되어 중복해서 나타나는 부분이다.<br/>
**"반복/중복은 분리해서 한 곳에서 관리하라"**

로직을 주입할 수 있는 곳(로직은 메서드의 안쪽에 위치한다.)
* 메서드 전 구역
* 메서드 시작 전
* 메서드 종료 후
* 메서드 정상 종료 후
* 메서드에서 예외가 발생하면서 종료된 후

@Aspect는 이 클래스를 이제 AOP에서 사용하겠다는 의미.<br/>
@Before는 대상 메서드 실행 전에 이 메서드를 실행하겠다는 의미.<br/>
JoinPoint는 @Before에서 선언된 메서드를 의미.<br/>

> 개발할 때는 여러 파일과 늘어난 코드의 양으로 수고를 해야하지만 추가 개발과 유지보수 관점에서 보면 무척이나 편한 코드가 된다.

빈이 설정되는 이유는 객체의 생성과 의존성 주입을 스프링 프레임워크에 위임하기 위해서다.<br/>
물론 스프링 프레임워크는 객체 생성뿐 아니라 객체의 생명주기 전반에 걸쳐 빈의 생성에서 소멸까지 관리한다.<br/>
```
<aop:aspectj-autoproxy />
```
스프링 AOP는 프록시를 사용한다.<br/>
호출하는 쪽에서나 호출 당하는 쪽, 그 누구도 프록시가 존재하는지조차 모른다.<br/>
> 오직 스프링 프레임워크만 프록시의 존재를 안다.<br/>
> 결국 위의 코드는 스프링 프레임워크에게 AOP 프록시를 사용하라고 알려주는 지시자이다.<br/> 게다가 auto가 붙었으니 자동으로.

AOP의 핵심
* 스프링 AOP는 인터페이스 기반이다.
* 스프링 AOP는 프록시 기반이다.
* 스프링 AOP는 런타임 기반이다.

#### AOP 용어
용어 | 영한 사전
-----|------
Aspect | 관점, 측면, 양상
Advisor | 조언자, 고문
Advice | 조언, 충고
JoinPoint | 결합점
Pointcut | 자르는 점

#### Pointcut - 자르는 지점? Aspect 적용 위치 지정자!
* 횡단 관심사를 적용할 타깃 메서드를 선택하는 지시자(메서드 선택 필터).
* "타깃 클래스의 타깃 메서드 지정자"
* Aspect 적용 위치 지정자(지시자)
* 메서드 선정 알고리즘
> [접근제한자패턴]**리턴타입패턴**[패키지&클래스패턴.]**메서드이름패턴**(**파라미터패턴**)[throws 예외패턴]<br/>
> []는 생략 가능 <br/>
> 필수 요소는 리턴 타입 패턴, 메서드 이름 패턴, 파라미터 <br/>

#### JoinPoint - 연결점? 연결 가능한 지점!
Pointcut은 JoinPoint의 부분 집합이다.
* AOP는 인터페이스 기반이다.
* 인터페이스는 추상 메서드의 집합체다.
* 그러므로 AOP는 메서드에만 적용 가능하다.
> Pointcut의 후보가 되는 모든 메서드들이 JoinPoint, 즉 Aspect 적용이 가능한 지점이 된다.<br/>
> JoinPoint란 **"Aspect적용이 가능한 모든 지점"**

스프링 AOP에서 JoinPoint란 스프링 프레임워크가 관리하는 빈의 모든 메서드에 해당한다.
* 광의의 JoinPoint란 Aspect 적용이 가능한 모든 지점이다.
* 협의의 JoinPoint란 호출된 객체의 메서드다.

#### Advice - 조언? 언제, 무엇을!
Advice는 pointcut에 적용할 로직, 즉 메서드를 의미하는데, 여기에 더해 언제라는 개념까지 포함한다.
> 결국 Advice란 Pointcut에 언제, 무엇을 적용할지 정의한 메서드다.<br/>
> 타깃 객체의 타깃 메서드에 적용될 부가 기능

* Aspect = Advice들 + Pointcut들<br/>
Advice - [언제(When), 무엇을(What)]
Pointcut - [어디에(Where)]
> Aspect = When + Where + What(언제, 어디에, 무엇을)

#### Advisor - 조언자? 어디서, 언제, 무엇을!
Advisor = 한 개의 Advice + 한 개의 Pointcut

Advisor는 다른 AOP 프레임워크에서는 사용하지 않으며 스프링 버전이 올라가면서 이제는 쓰지 말라고 권고하는 기능이다.<br/>
스프링이 발전해 오면서 다수의 Advice와 다수의 Pointcut을 다양하게 조합해서 사용할 수 있는 방법, 즉 Aspect가 나왔기 때문이다.<br/>

> POJO & XML 기반으로 변경할 시 스프링 프레임워크에 종속되지 않는다.
> 포인트 컷이 중복 될 경우 리팩토링 할 수 있다.
<hr/>

### PSA - 일관성 있는 서비스 추상화
서비스 추상화의 예 <br/>
* JDBC
  * JDBC라고 하는 표준 스펙이 있기에 오라클을 사용하든, MySQL을 사용하든, MS-SQL을 사용하든 Connection, Statement, ResultSet을 이용해 공통된
  방식으로 코드를 작성 할 수 있다. 데이터베이스 종류에 관계없이 같은 방식으로 제어할 수 있는 이유는 디자인 패턴에서 설명했던 어댑터(변환기) 패턴을
  활용했기 때문이다. 이처럼 어댑터 패턴을 적용해 같은 일을 하는 다수의 기술을 공통의 인터페이스로 제어할 수 있게 한 것을 서비스 추상화라고 한다.
  
스프링 프레임 워크에서는 서비스 추상화를 위해 다양한 어댑터를 제공한다.
* OXM(Object XML Mapping: 객체와 XML 매핑)기술
  * Castor, JAXB, XMLBeans, JiBX, XStream
    * 위의 다양한 기술들이 제공하는 제각각의 API를 위한 어댑터를 제공함으로써 실제로 어떤 OXM 기술을 쓰든 일관된 방식으로 코드를 작성할 수 있게 지원한다.
> 다른 OXM기술로 변경할 때 큰 변화 없이 세부 기술을 교체해서 사용할 수 있게 해준다.
* ORM
* 캐시
* 트랜잭션


