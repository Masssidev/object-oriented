# 객체 지향 설계 5원칙 - SOLID
* SRP(Single Responsibility Principle): 단일 책임 원칙
* OCP(Open Closed Principle): 개방 폐쇄 원칙
* LSP(Liskov Substitution Principle): 리스코프 치환 원칙
* ISP(Interface Segregation Priciple): 인터페이스 분리 원칙
* DIP(Dependency Inversion Principle): 의존 역전 원칙

응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것이다.<br/>
  * 결합도는 클래스간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
  * 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.
  
> SOLID를 잘 녹여낸 소프트웨어는 그렇지 않은 소프트웨어에 비해 상대적으로 이해하기 쉽고, 리팩터링과 유지보수가 수월할 뿐만 아니라 논리적으로 정연하다.
<hr/>

### SRP - 단일 책임 원칙
#### "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다"
예제로 이해하기<br/>
1. 남자 클래스
  * 남자 클래스는 남자친구 역할, 아들 역할, 사원 역할, 소대원 역할을 한다.
  * 여자친구와 헤어졌을 경우 필요도 없는 해당 기능들을 하고 있어야 한다.
  > 남자 클래스에 단일 책임 원칙을 적용해 여러개의 클래스로 분리한다. <br/>
  > (남자친구 클래스, 사원 클래스, 아들 클래스, 소대원 클래스)

2. 사람 클래스
  * 사람 클래스에는 군번 속성이 있다.
  * 여자일 경우 군번 속성이 필요 없다.
  > 사람 클래스를 상위 클래스로 두고 남자, 여자 클래스를 하위클래스로 두어 남자 클래스에만 군번 속성을 넣는다.
  
3. 강아지 클래스
  * 소변을 본다.
  * 수컷과 암컷은 소변 보는 자세가 다르다.
  > 괜한 if문으로 분기처리를 하지 말고 단일 책임 원칙을 적용해 리팩터링하자.<br/>
  > 강아지 클래스를 추상클래스로 두고 수컷, 암컷 클래스에서 상속하게 하여 소변보다 메소드를 따로 구현한다.

#### 캡상추다를 다시 상기해 보면 단일 책임 원칙과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 추상화이다.
애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자.
또한 리팩터링을 통해 코드를 개선할 때도 단일 책임 원칙을 적용할 곳이 있는지 꼼꼼히 살피자.
<hr/>

### OCP - 개방 폐쇄 원칙
#### "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다."
#### "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."
예제로 이해하기<br/>
1. JDBC
  * JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다.
  * 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충 장치로 인해 변화에 영향을 받지 않는다.
  > 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀 있고 데이터베이스가 자신의 확장에는 열려 있다.
2. 자바
  * 자바 개발자는 작성하고 있는 소스코드가 윈도우에서 구동될지, 리눅스에서 구동될지 또는 또 다른 운영체제 상에서 구동될지에 대해서는 걱정하지 않는다.
  * 각 운영체제별 JVM과 목적 파일(.class)이 있기에 개발자는 다양한 구동 환경에 대해서는 걱정하지 않고 본인이 작업하고 있는 개발 PC에 설치된 JVM에서 구동되는 코드만 작성하면 된다.
  > 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확장에 열려 있는 구조가 되는 것이다.<br/>
  > 개발자의 소스코드와 운영체제별 JVM 사이에는 목적파일이라고 하는 완충 장치가 있는 것이다.
3. 편의점
  * 편의점에서는 일일 삼교대로 직원이 교대한다. 주말에는 다른 아르바이트 직원이 근무하기도 한다. 하지만 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는 데는 영향이 없다.
  * 편의점 직원이 근본적으로 판매라고 하는 행위, 즉 손님과의 인터페이스가 바뀌지 않는 한 손님의 구매라는 행위는 직원이 세부적으로 구매 담당자든,
  보안 담당자든 심지어 남자에서 여자로, 학생에서 노인으로 교대한다고 해도 전혀 영향을 받지 않는다.
  > 직원 교대라고 하는 주변의 변화에 손님의 구매 행위는 영향을 받지 않는 것이고, 직원은 교대라고 하는 확장 행위에는 열려 있는 것이다.

##### 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
##### 따라서 객체 지향 프로그래밍에서 개방 폐쇄 원칙은 반드시 지켜야 할 원칙이다.
<hr/>

### LSP - 리스코프 치환 원칙
##### "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다."
* 하위 클래스 is kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
* 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.

``` 
아버지 춘향이 = new 딸();
```
딸을 하나 낳아서 이름을 춘향이라 했지만 아빠의 역할을 맡기고 있다.<br/>
> 리스코프 치환 원칙 위배

```
동물 뽀로로 = new 펭귄();
```
펭귄 한 마리가 태어나 뽀로로라 이름을 짓고 동물의 행위를 하게 하는 데 전혀 이상함이 없다.<br/>
> 리스코프 치환 원칙 만족

##### "하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다."

> 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다.
* 하위형에서 선행 조건은 강화될 수 없다.
* 하위형에서 후행 조건은 악화될 수 없다.
* 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

##### 상속 != 조직도, 계층도
##### 상속 = 분류도
<hr/>

### ISP - 인터페이스 분리 원칙
##### "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다."
* 단일 책임 원칙과 인터페이스 분할 원칙은 같은 문제에 대한 두 가지 다른 해결책이다.<br/>
* 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다.
* 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이다.
인터페이스 최소주의 원칙 : 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라<br/>
> 상위클래스는 풍성할수록 좋고, 인터페이스는 작을 수록 좋다.
* 풍성한 상위 클래스를 이용하면 빈약한 상위 클래스를 이용하는 것보다 사용 불가능한 경우나 불필요한 형변환이 없다.

> 인터페이스는 그 역할에 충실한 최소한의 기능만 공개하라
##### 인터페이스는 "~할 수 있는(is able to)"이라는 기준으로 만드는 것이 정석
<hr/>

### DIP - 의존 역전 원칙
##### "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
##### "추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
##### "자주 변경되는 구체클래스에 의존하지 마라"

예제로 이해하기
* 자동차 - 스노우타이어
  * 자주 변하는 스노우타이어에 의존하기에 부서지기 쉬움
  * 자동차가 구체적인 타이어들(스노우타이어, 일반타이어, 광폭타이어)이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 스노우타이어에서
  일반 타이어로, 또는 다른 구체적인 타이어로 변경돼도 자동차는 이제 그 영향을 받지 않는 형태로 구성된다.
  * 개방 폐쇄 원칙에도 나온 설명이다.
  * 기존에는 스노우타이어가 그 무엇에도 의존하지 않았지만 이제는 추상적인 것인 타이어 인터페이스에 의존하게 됐다.(의존의 방향이 역전)
  * 자동차는 자신보다 변하기 쉬운 스노우타이어에 의존하던 관계를 중간에 추상화된 타이어 인터페이스를 추가해 두고 의존 관계를 역전시킴
  * 자신보다 변하기 쉬운것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않음.

##### "자신보다 변하기 쉬운 것에 의존하지 마라."
> 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높다.
> 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것 **의존 역전 원칙**

### SoC 관심사의 분리
관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리<br/>
> 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다.<br/>
> 관심사가 다르고 변화의 시기가 다르면 분리해야 한다.<br/>
> SoC을 적용하면 자연스럽게 단일 책임 원칙, 인터페이스 분리 원칙, 개방 폐쇄 원칙에 도달하게 된다.
<hr/>

##### 정리 - SOLID
* SRP(단일 책임 원칙): 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
* OCP(개방 폐쇄 원칙): 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
* LSP(리스코프 치환 원칙): 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
* ISP(인터페이스 분리 원칙): 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
* DIP(의존 역전 원칙): 자신보다 변하기 쉬운 것에 의존하지 마라.
> SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아지는 경향이 있다.<br/>
> 하지만 이렇게 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉬우며, 유지와 관리, 보수하기 쉬운 소스가 만들어진다.


